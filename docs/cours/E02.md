# API E07 - Modules & Gestion d'erreurs

```
=== Matin COURS ===

- Correction
  - Ouverture/fermeture modale
  - Fetch et ajout de listes
  - Formulaire et insertion de liste

- Compléments
  - Gestion d'erreur
    - erreurs client / erreurs serveur
    - modale d'erreur
  - ECMAScript Modules (ESM)
    - architecture

=== Aprem ATELIER ===

- (DELETE) Suppression d'une liste
- (PATCH) Modification du nom d'une liste
- (Bonus - Drag & Drop) Modification de la position des listes
```

## Sommaire

- [Gestion des erreurs Fetch](#gestion-des-erreurs-fetch)
- [ECMAScript Modules (ESM)](#ecmascript-modules-esm)

## Cours

### Gestion des erreurs Fetch

Lorsqu'on utilise `fetch` pour récupérer des données depuis un serveur, il est important de gérer les erreurs qui peuvent survenir. Il y as 2 types d'erreurs :

Les "plantages" du navigateur (réseau, serveur injoignable, etc...) que l'on peut gérer avec un bloc `try...catch` de façon classique :

```js
try {
  const httpResult = await fetch("http://unexisting-api/todos");
  const data = await httpResult.json();
} catch (error) {
  console.log(error); // TypeError: Failed to fetch
}
```

Cette erreur sera déclenchée si le serveur est injoignable, si le réseau est coupé, etc...

En revanche, si le serveur répond avec une erreur HTTP (404, 500, etc...), le bloc `catch` ne sera pas déclenché. En effet, `fetch` considère que la requête a été correctement effectuée, et c'est à nous de vérifier si le serveur a répondu avec une erreur ou non. Pour cela, on peut utiliser la propriété `ok` de l'objet `Response` :

```js
try {
  const httpResult = await fetch("http://working-api/unexisting-mushroom");
  if (!httpResult.ok) {
    // Si le serveur a répondu avec une erreur on leve une exception manuellement
    throw new Error(httpResult.status);
  }
  const data = await httpResult.json();
} catch (error) {
  console.log(error);
  return null; // Par exemple, on retourne null pour indiquer qu'il y a eu une erreur
}
```

### ECMAScript Modules (ESM)

Afin de garder un code bien organisé et maintenable, il est important de bien structurer son code. Pour cela, on peut utiliser les modules ECMAScript (ESM) qui permettent de découper son code en plusieurs fichiers, et de les importer/exporter les uns dans les autres.

Pour créer un module, il suffit d'exporter les éléments que l'on souhaite rendre accessibles depuis l'extérieur grace au mot-clé `export` :

```js
// Dans un fichier "utils.js"
export function sum(a, b) {
  return a + b;
}
export function multiply(a, b) {
  return a * b;
}
```

```js
// Dans un fichier index.js par exemple
import { sum, multiply } from "./utils.js";

console.log(sum(2, 3)); // 5
console.log(multiply(2, 3)); // 6
```

Pour que cette syntaxe fonctionne, il est important de préciser que le fichier est un module en ajoutant l'attribut `type="module"` à la balise `<script>` dans le fichier HTML :

```html
<script type="module" src="index.js"></script>
```
