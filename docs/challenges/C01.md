# O'kanban - SPA E01 - Fetch et templates

‚ö†Ô∏è **Le retour du front !** Pensez √† `console.log` apr√®s chaque ligne pour tester r√©guli√®rement ‚ö†Ô∏è

‚ö†Ô∏è `Commit` entre chaque √©tape ! On ne le dira jamais assez ü§™ ‚ö†Ô∏è

## √âtape 1 - Mise en place

### 1.1. Lancer le back ü¶ø

R√©-ouvrir le projet O'kanban API (backend) et d√©marrer l'API sur le port de votre choix.

V√©rifier que l'API r√©pond correctement (avec Insomnia par exemple), et que votre code est √† jour par rapport √† la correction.

### 1.2. Lancer le front ü¶æ

Pour ce projet, le frontend est ind√©pendant du backend, et on communiquera avec lui via son API.

C√¥t√© frontend, tout va se passer dans le navigateur. On va donc coder directement des fichiers statiques (`HTML`, `CSS`, `JS`). Retour en S2, en quelque sorte !

L'option la plus simple pour **lancer un serveur front** est d'utiliser l'extension VSCode `Live Server` en cliquant droit sur le fichier `html` √† ouvrir,
et choisir `Open with Live Server`. On profite ainsi du _hot reload_ (rechargement automatique de la page en cas de modification du code c√¥t√© front).

### 1.3. Prise en main du code üëÄ

Commencer par **lire les fichiers d'int√©gration fournis** et rep√©rer les √©l√©ments sur la page.
L'int√©gration propos√©e utilise le framework [CSS Bulma](https://bulma.io/). Un petit tour sur la documentation ne fait pas de mal.

## √âtape 2 - La fen√™tre modale

> Une modale est une fen√™tre r√©duite qui s'ouvre dans le navigateur par dessus le contenu courant, √† la mani√®re d'une popup.

### 2.1. Ouvrir la modale

Tu as d√ª remarquer le bouton `Ajouter une liste`. Mais ce bouton‚Ä¶ ne fait rien !

Tu as d√ª aussi remarquer la pr√©sence d'une `<div class="modal">` dans le code.

**Objectif** : lorsque l'on clique sur le bouton, la modale apparait. √Ä toi de jouer !

<details><summary>De l'aide ?</summary>

L'id√©e est d'ajouter la classe `is-active` √† la modale pour l'afficher : lorsque l'utilisateur clique sur le bouton, on ajoute cette classe.

<details><summary>Pseudo code</summary>

```js
// - s√©lectionner le bouton ‚Üí `querySelector()`
// - √©couter le click sur le bouton, et en cas de clic ‚Üí `addEventListener()`
//   - s√©lectionner la modale ‚Üí `querySelector()`
//   - lui ajouter la classe 'is-active' ‚Üí `classList.add()`
```

</details>

</details>

### 2.2. Fermer la modale

On souhaite pouvoir fermer la modale de 3 fa√ßons diff√©rentes :

- un clic sur la croix `x` en haut √† droite de celle-ci ;
- un clic sur le bouton `Annuler` en bas ;
- (bonus) un clic sur le fond gris√© derri√®re la modale.

L'objectif de cette √©tape est de faire fonctionner ces boutons.

<details><summary>De l'aide ?</summary>

L'id√©e est de retirer la classe `is-active` lors d'un clic sur l'un des deux boutons. Comme d'habitude :

- s√©lectionner un √©l√©ment ;
- poser un √©couteur d'√©v√®nement ;
- retirer une classe‚Ä¶

</details>

### 2.3. Un peu de rangement üßπ ?

On pourrait rassembler, dans des fonctions sp√©cifiques et bien nomm√©es, :

- les instructions qui posent l'√©couteur pour ouvrir la modale ;
  > ex : `listenToClickOnAddListModal()`
- les instructions qui posent les √©couteurs pour fermer la modale ;
  > ex : `listenToClickOnModalClosingElements()`
- les instructions qui ferment sp√©cifiquement la modale couramment active.
  > ex : `closeActiveModal()`

Puis on s'assure d'appeler ces fonctions lorsque l'int√©gralit√© du DOM est bien charg√© par le navigateur :

```js
document.addEventListener("DOMContentLoaded", () => {
  // maFonction();
  // maFonction2();
});
```

## √âtape 3 - Fetch fetch fetch

### 3.1. Retirer les listes cod√©es en dur

Notre kanban pr√©sente des listes qui ont √©t√© cod√©es en dur dans l'int√©gration.

On les retire pour faire place nette avant d'ins√©rer celles provenants de l'API !

> **ATTENTION** ne pas retirer le conteneur des listes (`lists-container`) dont on aura besoin.

### 3.2. Requ√™ter les listes via l'API

√Ä l'aide d'une requ√™te HTTP (via `fetch`) vers notre API, on r√©cup√®re les donn√©es des listes par la route `GET /lists`.

Rappel de l'utilisation de `fetch` dans une fonction `async`.

```js
const httpResponse = await fetch(URL); // on r√©cup√®re une Response
const data = await httpResponse.json(); // on transforme le corps de la r√©ponse (JSON) en Objet JS
console.log(data);
```

Une fois les donn√©es r√©cup√©r√©es, on les `console.log` et on passe √† la suite : les afficher !

### 3.3. Ins√©rer les listes dans la page

Maintenant que nous avons r√©cup√©r√© les listes, on voudrait les afficher dans la page. On pourrait utiliser des `document.createElement` √† tout va,
mais on va vite avoir un sacr√© paquet d'√©l√©ments √† cr√©er‚Ä¶

Mais attendez‚Ä¶ quelle chance ! Nous avons un `<template>` HTML √† notre disposition. On peut donc s'en servir pour ins√©rer nos listes dans la page !

<details><summary>Un peu d'aide ?</summary>

```js
// === PSEUDO CODE ===

// S'assurer d'avoir bien r√©cup√©rer les listes √† l'√©tape pr√©c√©dente : [{ ... }, { ... }, { ... }]

// Pour chaque liste :
// - cloner le template
// - changer le contenu de l'√©l√©ment avec le slot `list-title` (du clone) par le titre de la liste r√©cup√©r√©e
// - changer l'ID de l'√©l√©ment avec le slot `slit-id` (du clone) par l'ID de la liste r√©cup√©r√©e
// - s√©lectionner l'√©l√©ment conteneur des listes
// - ins√©rer le clone dans le conteneur

// Festoyer !
```

</details>

### 3.4. Un peu de rangement üßπ ?

On pourrait rassembler, dans des fonctions sp√©cifiques et bien nomm√©es, :

- les instructions qui affichent une liste sur la page √† partir des donn√©es d'une liste (objet) fournie en **param√®tre** ;
  > ex : `addListToListsContainer(listData)`
- les instructions qui vont chercher les listes via l'API dans une fonction qui **retourne** ces listes une fois r√©cup√©r√©es ;
  > ex : `getLists()`
- et pourquoi pas le tout dans une fonction regroupant les instructions pr√©c√©dentes.
  > ex : `fetchAndDisplayLists()`

## √âtape 4 - Ajout d'une nouvelle liste

### 4.1. Soumission du formulaire

On reprend notre modale de l'√©tape 2, qui pr√©sente un formulaire HTML `<form>` √† l'utilisateur.

Lorsque l'utilisateur **soumet** (`submit`) ce formulaire , on souhaite :

- emp√™cher le comportement par d√©faut du formulaire ;
  > `event.preventDefault()` : et oui, on va g√©rer la requ√™te HTTP manuellement !
- r√©cup√©rer les donn√©es du formulaire ;
  > une [fa√ßon efficace ici](https://stackoverflow.com/questions/3547035/getting-html-form-values)
- les afficher en `console` pour tester ;
- fermer la modale apr√®s soumission ;
- et √©ventuellement `reset` le formulaire.

Une fois que les donn√©es sont bien affich√©es en `console`, on passe √† la suite.

### 4.2. Sauvegarder la nouvelle liste

Il est temps d'ex√©cuter une requ√™te `POST /lists` vers notre API afin que celle-ci s'occupe de l'ajouter en base de donn√©es.

Rappel de l'utilisation de `fetch` pour une requ√™te POST :

```js
const httpResponse = await fetch(URL, {
  method: "POST", // je cible la route `POST`
  headers: { "Content-Type": "application/json" }, // je pr√©viens que j'envoie du JSON
  body: JSON.stringify(myData), // j'envoie mes donn√©es en JSON
});
const data = await httpResponse.json();
console.log(data); // Les donn√©es JSON renvoy√©es par l'API r√©cup√©r√©es en objet JS
```

On v√©rifie que l'API nous renvoie une r√©ponse correcte et que la liste a bien √©t√© ajout√©e en base de donn√©es.

### 4.3. Ins√©rer la nouvelle liste sur la page

Bonne nouvelle : nous avons d√©j√† cod√© une fonction pour ins√©rer une liste sur la page √† partir des donn√©es d'une liste : `addListToListsContainer(listData)`.
On peut donc la r√©utiliser et ins√©rer la liste fraichement cr√©√©e dans le DOM.

### 4.4. Un peu de rangement üßπ ?

On pourrait rassembler, dans des fonctions sp√©cifiques et bien nomm√©es, :

- les instructions qui √©coutent la soumission du formulaire ;
  > ex : `listenToSubmitOnAddListForm()`
- les instructions qui envoient la requ√™te `POST` et **retourne** les donn√©es renvoy√©es par le serveur ;
  > ex : `createList(listData)`

## Fin

**Bravo !** Vous avez r√©alis√© votre premi√®re ¬´ _Single Page Application_ ¬ª (SPA) qui g√®re les donn√©es de mani√®re dynamique,
sans recharger la page entre chaque changement d'√©tat de la base de donn√©es !
